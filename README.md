# Python for  you


![](https://upload-images.jianshu.io/upload_images/7600498-607a6f08355efbab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


###### Python是什么

一门编程语言，或者，简化了的英语。

Python的作者，Guido von Rossum，确实是荷兰人。1982年，Guido从阿姆斯特丹大学(University of Amsterdam)获得了数学和计算机硕士学位。然而，尽管他算得上是一位数学家，但他更加享受计算机带来的乐趣。就像数学家的追求一样，Python优美、清晰、简单。

![](https://upload-images.jianshu.io/upload_images/7600498-e32c3bb67fa55b47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)


Guido希望有一种语言，这种语言能够像C语言那样，能够全面调用计算机的功能接口，又可以像shell那样，可以轻松的编程。ABC语言让Guido看到希望。ABC是由荷兰的CWI (Centrum Wiskunde & Informatica, 数学和计算机研究所)开发的。Guido在CWI工作，并参与到ABC语言的开发。ABC语言以教学为目的。与当时的大部分语言不同，ABC语言的目标是“让用户感觉更好”。ABC语言希望让语言变得容易阅读，容易使用，容易记忆，容易学习，并以此来激发人们学习编程的兴趣。

据说，1989年圣诞节，Guido 在阿姆斯特丹很无聊，决定开发一种新的脚本解释语言，之所以选择Python（大蟒蛇）作为程序的名字，是因为他是一个大蟒蛇飞行马戏团（Monty Python）的爱好者。他的爱好很是广泛，看起来像无所事事的样子，前段时间还参与了996的讨论。


1991年，第一个Python编译器(同时也是解释器)诞生。它是用C语言实现的，并能够调用C库(.so文件)。从一出生，Python已经具有了：类(class)，函数(function)，异常处理(exception)，包括表(list)和词典(dictionary)在内的核心数据类型，以及模块(module)为基础的拓展系统。借助社区优势贪婪的Python越来越强大，更新也很及时，像许多九零后一样，开始奔三了：最新版为3.7.3.

一门有三观的语言：

```
Python之禅 by Tim Peters
 
优美胜于丑陋（Python 以编写优美的代码为目标）
明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）
简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）
复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）
扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）
间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）
可读性很重要（优美的代码是可读的）
即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）
不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码）
当存在多种可能，不要尝试去猜测
而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）
虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido ) 
做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）
如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）
命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）
```



##### 为什么用Python

来自知乎网友的回答：因为用它可以优雅快速表达自己的逻辑。

现实是，Python意味着一套思维逻辑，更好的工作效率，更多的就业机会，以及更多的乐趣。

学习任何一项技能都是需要原因的，因为这要花很长的时间，有时候比一段婚姻还要长。如果没有初心的强烈认同，从入门到入坟这段旅程将会非常快。学习Python最好的时间是十年前，其次是现在。它像一个善解人意的贤内助（目前还是大众情人），能做很多你也许都没想到的温暖情。

+ 因为它能做很多事，所以很流行。

我们常见的网站中，涉及python做web开发的有： 等等Reddit ，豆瓣网，知乎，Quora，Google。

![2019-05](https://upload-images.jianshu.io/upload_images/7600498-cf68c009c8dca8f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)


+ 快速学习曲线和缩短开发时间。

Python来自一门ABC语言，这门语言的初衷就是让不懂编程的人快速成为程序猿，ABC就是很简单的意思。然后Python比ABC还要简单，所以入门者甚众。

Python比大多数其他流行的面向对象编程语言（如Java）更容易学习。与其他语言相比，Python中的语法和语义更加干净整洁，代码也更具可读性。需要用Python编写代码行来解决特定问题，在大多数情况下，这将比其他流行语言所需的代码少得多。 Python中的模块化体系结构使得导入和使用模块变得容易。


+ 自动执行日常重复性任务 .

由于社会的分工越来越细，人们从事的工作大部分也都是重复性质的。发邮件，测试报告等，为什么不写一个脚本自动化处理呢？

此处省略一份资料。

![](https://upload-images.jianshu.io/upload_images/7600498-d5472ed3d7d0f907.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/240)

+ 数据科学与分析的热门选择 

Python是数据科学和分析领域中最受欢迎的编程语言之一。Python具有成熟且功能丰富的模块，因此更容易以高效的方式支持数据分析。用于不同目的分析堆栈中的一些流行模块如下所述，供你参考：

NumPy：该模块提供了庞大的数学函数库以及对多维数组的支持，这对数据科学至关重要。该模块提供数值数组和矩阵数据类型和函数，以便对该数据进行操作。

SciPy：此实用程序提供了一组算法，可用于不同的域特定数据处理。这包括统计算法，数字信号处理算法等。有关更多详细信息和官方文档，请参阅SciPy的官方网站。

matplotlib：这是一个流行的绘图包，可用于2D和基本3D绘图。这个包非常重要，因为[数据可视化](https://cloud.tencent.com/product/yuntu?from=10680)在数据科学中非常重要。

pandas：这是一个开源且易于使用的库，提供高性能的数据结构和数据分析工具。

+  人工智能与机器学习的未来

机器学习无处不在，从自动驾驶汽车到深入学习人工智能，可以击败复杂战略游戏中最优秀的人类玩家。新的可能性几乎无穷无尽。你开发的机器学习算法可能会彻底改变某些行业。Python是机器学习项目和AI相关项目的首选语言，包括谷歌在内的许多大型科技公司都将Python用于机器学习项目。以下是一些流行的机器学习模块和框架：

Tensorflow：这是一个用于编程神经网络架构的神经网络库。它由Google开发，目前正被许多从事机器学习项目的开发人员使用。 Tensorflow提供高级功能，因此你无需重新发明轮子。它具有灵活的架构，可以让你创建有意义的解决方案。

Scikit-learn：这也是一个基于NumPy和SciPy构建的流行ML库，开发人员广泛使用它。

```
以上参考《4 Reasons You Should Learn Python》
作者：Arani Chatterjee
译者：lemon
```

##### 怎样使用Python

其实解决了**Python是什么** 以及 **为什么用Python**两个问题剩下的就很简单了呢：时间，重复，Google。

其实这已经够了。

但是作为Python教程如果一行代码都不出现是不是不太好呢？显然是的。学习一门语言要知道它基本：
+ 编程环境
+ 语法
+ 数据类型
+ 控制结构
+ 文档管理
+ 函数与模块



在基础阶段，这里推荐的一份资料是《笨办法学Python》它不仅提供学习Python的方法，其他语言也可以触类旁通，重要的是：你会在里面看到自己当年学习英语的样子，比如制作卡片，背单词，阅读理解等等。

此处省略一=一份资料。

![](https://upload-images.jianshu.io/upload_images/7600498-5cce6b747777a95d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/140)


+ 编程环境

Python是跨平台的，它可以运行在Windows、Mac和各种Linux/Unix系统上。在Windows上写Python程序，放到Linux上也是能够运行的。

要开始学习Python编程，首先就得把Python安装到你的电脑里。安装后，你会得到Python解释器（就是负责运行Python程序的），一个命令行交互环境，还有一个简单的集成开发环境。

从官网[https://www.python.org/](https://www.python.org/)下载安装文件。下载安装后，配置环境变量，即可运行在命令行Python。
![](https://upload-images.jianshu.io/upload_images/7600498-d01b91d075e6485f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

Anaconda[https://www.anaconda.com/](https://www.anaconda.com/)安装与管理Python包。


如交互环境如下：
```
python
Python 2.7.14 (default, Oct 24 2017, 17:40:36)
[GCC 4.4.7 20120313 (Red Hat 4.4.7-18)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> print"welcome to  python!"
welcome to python!
>>>
```

Python 的学习过程少不了 IDE 或者代码编辑器，或者集成的开发编辑器（IDE）。这些 Python 开发工具帮助开发者加快使用 Python 开发的速度，提高效率。高效的代码编辑器或者 IDE 应该会提供插件，工具等能帮助开发者高效开发的特性。
[推荐10 款最好的 Python IDE]()

![Spyder](https://upload-images.jianshu.io/upload_images/7600498-0e55e044564181f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

作为练习也可以免去配置环节，用在线环境，如[https://c.runoob.com/compile/6](https://c.runoob.com/compile/6)

![](https://upload-images.jianshu.io/upload_images/7600498-ed13c14502855673.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

+ 语法

语言的结构规则：[https://www.runoob.com/python/python-basic-syntax.html](https://www.runoob.com/python/python-basic-syntax.html)

Python 标识符
在 Python 里，标识符由字母、数字、下划线组成。

在 Python 中，所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头。

Python 中的标识符是区分大小写的。

以下划线开头的标识符是有特殊意义的。以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入。

以双下划线开头的 __foo 代表类的私有成员，以双下划线开头和结尾的 __foo__ 代表 Python 里特殊方法专用的标识，如 __init__() 代表类的构造函数。

Python 可以同一行显示多条语句，方法是用分号 ; 分开，如：

```
>>> print 'hello';print 'runoob';
hello
runoob
```
一些保留字不能用作常数或变数，或任何其他标识符名称。所有 Python 的关键字只包含小写字母。
```
and	exec	not
assert	finally	or
break	for	pass
class	from	print
continue	global	raise
def	if	return
del	import	try
elif	in	while
else	is	with
except	lambda	yield
```
行和缩进
学习 Python 与其他语言最大的区别就是，**Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断**。python 最具特色的就是用缩进来写模块。

缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个**必须严格执行**。

```
>>> if True:
...     print"True"
...
True
>>> if True:
... print"True"
  File "<stdin>", line 2
    print"True"
        ^
IndentationError: expected an indented block

```

Python 可以使用引号( ' )、双引号( " )、三引号( ''' 或 """ ) 来表示字符串，引号的开始与结束必须的相同类型的。其中三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。python中单行注释采用 # 开头。

函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。

记住：空行也是程序代码的一部分。

+ 数据类型

数据类型在数据结构中的定义是一组性质相同的值的集合以及定义在这个值集合上的一组操作的总称。 变量是用来存储值的所在处，它们有名字和数据类型。

|变量类型|操作符	|说明|
|:--:|:--:|:--:|
|字符串	|str	|字符串是用来表示文本的数据类型。不同于C语言，python中单引号和双引号定义的字符串等价。|
|数值	|int & float	|类似其它大多数编程语言，python也将数值类型分为整型（int）和浮点型（float）。整数与数学上的定义相同，浮点数指数学上的小数。|
|列表	|list|列表是我们在python中很常用的一种数据类型。它是一种有序，可增减元素的数据集。|
|字典	|dict	|字典是一种键和值对应的一种数据类型，以键索引值。当你需要构建一一对应关系的时候，需要|
|元组	|tuple	|元组是有序的数据集， 无法增加和删除元素。|
|集合	|set|	集合，无序，无重复元素。支持数学上概念的，交集，并集，差集等。|
|布尔型	|boolean	|布尔值是一个逻辑值. 只有 True 和 False (真和假)两个值。|

数值，运算符号同小学数学。
```
>>> # 初始化int型
... num1 = int()
>>> print num1
0
>>> # 初始化float型
... num1 = float()
>>> print num1
0.0
>>> # 其他类型转化
... num1 = float("1.1")
>>> print num1
1.1
```
```
>>> num1 = num1 + 12
>>> print num1
13.1
>>> num1 += 1
>>> print num1
14.1
>>> # 幂次，**
... num1 = 5.3**2
>>> print num1
28.09
>>> # 取余，%
... 3 % 2
1
>>> # 整除，//
... 5 // 2
2
```

字符串，数值操作函数和math模块

```
print abs(-2) #绝对值
print pow(3,2) #幂运算，相关于3**2
import math
print math.pi #圆周率
print math.e #常量自然数
print  math.log(10) #取自然对数
print math.log10(10) #以10对底的对数 

2
9
3.14159265359
2.71828182846
2.30258509299
1.0

```

字符串 (str)与正则表达式

```
初始化字符串

# 定义空字符串
str1 = str()
str1 = ""
str1 = ''
# 定义非空字符串
str1 = "I'm fine"
str1 = 'I\'m fine'
# 其它类型转化
str1 = str(3.1415926)
```
可以对字符串进行拼接，分割，匹配等操作。

```
# 字符串拼接
print  "a" + "b"
# 字符串复制
print "a" * 3
# 字符串格式化
print   "a%sa"%("b")
print   "a%da"%(1)
ab
aaa
aba
a1a
```
对字符串操作的函数

```

# 获取str长度
str1 = "bca"
print  len("abc") 
# 序列化
print   list(str1)
print   set(str1)
print   tuple(str1)
print   sorted(str1)

3
['b', 'c', 'a']
set(['a', 'c', 'b'])
('b', 'c', 'a')
['a', 'b', 'c']

```

字符串具有的属性
```
# 替换元素: replace
print  "abcdaf".replace("a","123")
# 定位元素: find; index 
print   "abcdaf".find("b")  
print  "abcdaf".index("b")
# 统计元素数量: count; 
print  "abcdaf".count("a")
# 起始终止: startswith; endswith;
print  "abcdaf".startswith("ab")
print  "abcdaf".startswith("ax")
# 分隔字符: split
print  "abcdaf".split("bc")
# 剪切: strip; lstrip; rstrip;
# 大小写: upper; lower; capitalize;
print  "aaa".upper() #小写变大写
print  "AAA".lower() #大写变小写
print  "aaa".capitalize() #将字符串的第一个字母变成大写,其他字母变小写 

123bcd123f
1
1
2
True
False
['a', 'daf']
AAA
aaa
Aaa
```
正则表达式[https://www.runoob.com/python/python-reg-expressions.html](https://www.runoob.com/python/python-reg-expressions.html)


正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。

re 模块使 Python 语言拥有全部的正则表达式功能。

compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。
re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。

|literal	|匹配字符串的值	|novogood|
|:--:|:--:|:--:|
|re1\|re2	|匹配表达式re1或re2	|novo\|gene|
|.	|匹配任何字符（换行符除外）	|.|
|^	|匹配字符串的开始	|^Novo|
|$	|匹配字符串的结尾	|Novo$|
|*	|匹配前面出现的正则表达式零次或多次|	.*|
|+	|匹配前面出现的正则表达式一次或多次	|.+|
|?	|匹配前面出现的正则表达式零次或一次	|.？|
|{n}	|匹配前面重复n次的正则表达式	|a{3}|
|{m,n}	|匹配前面重复m次到n次的正则表达式	|a{m,n}|
|[…]	|匹配字符组里出现的任意一个字符|	[abcd]|
|[x-y]	|匹配从字符x到字符y中的任意一个字符|	[A-Za-z]|
|[^…]	|不匹配字符集中出现的任一字符	|[^abcd]|

|标识|意义|
|:-:|:-:|
|\d	|匹配任意数字，和[0-9]一样|
|\D	|与\d反义，匹配任意非数字字符|
|\w	|匹配任意数字字母字符，和[A-Za-z0-9]一样|
|\W	|和\w反义|
|\s	|匹配任何空白符，和[\n\t\r\v\f]一样|
|\S	|与\s反义|
|\	|转移字符|
```

import re

pattern = 'this'
text = 'Does this text match the pattern?'
match = re.search(pattern, text)
s = match.start()
e = match.end()

print('Found "{}"\nin "{}"\nfrom {} to {} ("{}")'.format(
    match.re.pattern, match.string, s, e, text[s:e]))

Found "this"
in "Does this text match the pattern?"
from 5 to 9 ("this")

import re
print(re.match('www', 'www.runoob.com').span())  # 在起始位置匹配
print(re.match('com', 'www.runoob.com'))         # 不在起始位置匹配

(0, 3)
None

```
re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。


检索和替换 

```
import re
 
phone = "2004-959-559 # 这是一个国外电话号码"
 
# 删除字符串中的 Python注释 
num = re.sub(r'#.*$', "", phone)
print "电话号码是: ", num
 
# 删除非数字(-)的字符串 
num = re.sub(r'\D', "", phone)
print "电话号码是 : ", num
```


```
import re
 
pattern = re.compile(r'\d+')   # 查找数字
result1 = pattern.findall('runoob 123 google 456')
result2 = pattern.findall('run88oob123google456', 0, 10)
print(result1)
print(result2)

['123', '456']
['88', '12']
```

+ 列表 (list)

python的列表个跟清单的道理是一样的，特点就是：可重复，类型可不同。类型不同也是跟数组最本质的区别了。
初始化列表
空list定义: list() , []
非空list定义: [1,2,3]
其它类型转化

```

list1=['a','b','c']
print  list1[0] #第一个元素
print  list1[-2] #倒数第二个元素
print  list1[::-1][1] #倒数第二个元素
#print  list1[::-1]
#print  list1[::]

#切片
print list1[0:2] #第1到2个
print list1[:] #0到最后

print('1' in list1)

print  len(list1) #获取list长度
print   max(list1) #获得list最大值
print   min(list1) #获得list最小值
# del 删除元素
del list1[0]  #删除第一个元素
print   sorted(list1) #对列表进行排序
print  ("".join(list1) )#列表合并成字符串

a
b
b
['a', 'b']
['a', 'b', 'c']
False
3
c
a
['b', 'c']
bc

```
列表具有的属性 

```
list1 = [1,3,2]
# 添加元素
list1.append(5) #在列表后面插入数值5
print list1
list1.extend([6,5]) #在列表后面插入列表[6,5]
print list1
list1.insert(1,8) #在第一个位置之后插入数值8
print list1
# remove: 移除列表中的某个值的第一个匹配项
list1.remove(2)
print list1
# list.pop([index=-1])
# obj -- 可选参数，要移除列表元素的索引值，不能超过列表总长度，默认为 index=-1，删除最后一个列表值。
list1.pop()
print list1

[1, 3, 2, 5]
[1, 3, 2, 5, 6, 5]
[1, 8, 3, 2, 5, 6, 5]
[1, 8, 3, 5, 6, 5]
[1, 8, 3, 5, 6]

```

```
print "#------我是分割线"
# 是否包含元素: __contains__. (类似于 in)
print list1.__contains__(1)
print  list1.__contains__(8)
# 索引元素: __getitem__. (list1[0])
print  list1.__getitem__(0) #类似于 list1[0]

# 获得元素索引值: index. 
print  list1.index(8)
# 某元素个数: count. 
print  [1,2,1,1].count(1)
# 排序: sort. (sorted(list1))

list1.sort()
print list1 
# 逆序: reverse, (list1[::-1])
list1.reverse()
print list1 

#------我是分割线
True
True
1
1
3
[1, 3, 5, 6, 8]
[8, 6, 5, 3, 1]

```

字典是另一种可变容器模型，且可存储任意类型对象。

字典的每个键值 key=>value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中 ,格式如下所示：
```
d = {key1 : value1, key2 : value2 }
```

```
# 空字典:
dict1 = {}
dict1 = dict()
# 非空字典
dict1  = {"a": 1, 2: [1,2]}
print  dict1 
dict1 = dict.fromkeys("ab", 1)
print  dict1 
dict1 = dict.fromkeys([1,2,3],1)
print  dict1 
# 其它类型转化  
dict1 = dict(([1,2],(3,4),"ab"))
print  dict1 

dict1 = dict.fromkeys("ab",1)
# 键和值的映射
print dict1["a"]
# 添加/修改映射
dict1["d"] = (1,2)
print dict1
# 删除映射
del dict1["a"]
print dict1

print "".join(dict1)
print  "".join(dict1.keys())




{'a': 1, 2: [1, 2]}
{'a': 1, 'b': 1}
{1: 1, 2: 1, 3: 1}
{'a': 'b', 1: 2, 3: 4}
1
{'a': 1, 'b': 1, 'd': (1, 2)}
{'b': 1, 'd': (1, 2)}
bd
bd
```
可以对字典操作的函数
len，获取dict长度
max, 获得dict的键的最大值
min，获得dict的键的最小值
sorted, 对字典的键排序
字典具有的属性
获得字典所有的键: dict1.keys()
获得字典所有的值: dict1.values()
合并字典: update
键是否存在: has_key


删除一对映射:
```

dict1 = {'b': 1, 'd': (1, 2)}
# pop 删除键对应的对象
dict1.pop('b') # 类似于 del dict1["b"]
print dict1
# popitem() 方法随机返回并删除字典中的一对键和值(一般删除末尾对)
dict1.popitem()
print dict1

{'d': (1, 2)}
{}
```
列表解析&字典解析
在需要改变列表而不是需要新建某列表时，可以使用列表解析。列表解析表达式为：

[expr for iter_var in iterable]
首先迭代iterable里所有内容，每一次迭代，都把iterable里相应内容放到iter_var中，再在表达式中应用该iter_var的内容，最后用表达式的计算值生成一个列表。 
 [expr for iter_var in iterable if cond_expr] 
加入了判断语句，只有满足条件的内容才把iterable里相应内容放到iter_var中，再在表达式中应用该iter_var的内容，最后用表达式的计算值生成一个列表。 


```
mydna= "ACTGCTCTAGCTAAGCA"
redna=''
for each in mydna:
	if each =='A':
		redna='T'+redna
	elif each =='T':
		redna='A'+redna
	elif each =='C':
		redna='G'+redna
	elif each =='G':
		redna='C'+redna
	else:
		redna='N'+redna

print redna

TGCTTAGCTAGAGCAGT

```

```
mydna= "ACTGCTCTAGCTAAGCA"
rule = {'A':'T','T':'A','G':'C','C':'G','N':'N'}
print ''.join([rule[n] for n in mydna[::-1]])
TGCTTAGCTAGAGCAGT
```

```
mydna= "ACTGCTCTAGCTAAGCA"
print ''.join(["ATCG"["TAGC".index(n)] for n in mydna[::-1]])

TGCTTAGCTAGAGCAGT
```



Python的集合(set)和其他语言类似, 是一个无序不重复元素集, 基本功能包括关系测试和消除重复元素. 集合对象还支持union(联合), intersection(交), difference(差)和sysmmetric difference(对称差集)等数学运算.由于集合是无序的,所以，sets 不支持 索引, 分片, 或其它类序列（sequence-like）的操作。

```
# 使用 set 函数创建集合
list1 = [6, 7, 7, 8, 8, 9]
set2 = set(list1)

set2.add(10)  # 添加新元素
print set2  # set([8, 9, 10, 6, 7])  去掉重复内容,而且是无序的

set3 = frozenset(list1)
#set3.add(10)  # 固定集合不能添加元素，会报错AttributeError: 'frozenset' object has no attribute 'add'

### 集合有并集，交集，求差操作
### a & b 并集：intersection() 方法返回一个新集合，包含在两个集合中同时出现的所有元素。
### a | b 交集：union() 方法返回一个新集合，包含在两个 集合中出现的元素。
### a - b 差集：difference() 方法返回的新集合中，包含所有在 集合A出现但未在集合B中的元素。
### a ^ b 对称差集：symmetric_difference() 方法返回一个新集合，包含所有只在其中一个集合中出现的元素。

# 删除元素
set2.discard(6)   # 当元素不存在时,不会引发异常
set2.remove(6)    # 与discard的区别在于，如果没有要删除的元素，remove会引发一个异常
set2.pop()  # 因为set是无序的，所以pop会随机的从set中删除一个元素
```

元组(Tuple)

元组和列表在结构上没有什么区别，唯一的差异在于元组是只读的，不能修改。元组用“()”表示

```
tuple1 = tuple("abc")
tuple1 = ("a","b","c")
tuple1 = ("a","b")+("c")

```
tuple类型的特性

同列表类似，也是有序的
但不可直接更改一级子元素
可用作dict的键: dict1 = {(‘a’,’b’): 2}
获取某元素数量: tuple1.count(“a”)
获取某元素索引: tuple1.index(“a”)

Python中的布尔类型有两个常量True和False表示。

在Python中所有的对象都可以进行真值测试，下面罗列一下判断为假的情况：
```
None
False
数值中的零，包括0，0.0，0j（虚数）
空序列，包括空字符串(”)，空元组(())，空列表([])
空的字典{}
自定义的对象的实例，该对象的__bool__方法返回False或者__len__方法返回0
```
除了以上的情况外，所有的对象在if或者while语句中的表现都为真。


在Python中布尔值可以进行或、且、否三种操作，与很多语言不同的是，Python中不是用符号，而是用英文单词来表示，分别是or、and和not。

需要注意的是or和and都支持短路操作，如果or的左边返回True，则右边就不会判断；同理如果and左边返回False，右边也不会进行判断。

not的优先级很低，not a == b表示的是not (a == b)，而表达式a == not b会直接报错，需要加括号a == (not b)。

```
bool1 = bool() 

print  bool1
bool2 = True 
print  bool2

# 或运算
print bool1 or bool2
# 和运算
print bool1 and bool2
# 非运算
print not bool1

False
True
True
False
True
```

```
print isinstance(1,int)
print isinstance({"a":'1'},list)
True
False

print type(1)
print type({'a':11})

<type 'int'>
<type 'dict'>



```


+ 控制结构 

无论在哪种高级语言中，都有3大程序结构，分别是顺序、选择、循坏结构。这三种结构可以用描述需要重复执行或者进行决策的需求。

一.顺序结构 
这种是最简单的结构,也是最普遍的结构。因为根据冯诺依曼的设计原理，程序是如果不改变程序执行顺序的话，默认顺序向下执行。

二.选择分支结构 
当对一或多个条件进行判别时,通常需要使用该结构。 
Python条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。

可以通过下图来简单了解条件语句的执行过程:

![](https://upload-images.jianshu.io/upload_images/7600498-198d895180b7595a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

Python程序语言指定任何非0和非空（null）值为true，0 或者 null为false。

Python 编程中 if 语句用于控制程序的执行，基本形式为：


```
if 判断条件：
    执行语句……
else：
    执行语句……
```


```
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
# 例1：if 基本用法
 
flag = False
name = 'luren'
if name == 'python':         # 判断变量是否为 python 
    flag = True              # 条件成立时设置标志为真
    print 'welcome boss'     # 并输出欢迎信息
else:
    print name               # 条件不成立时输出变量名称
```

循环语句允许我们执行一个语句或语句组多次，Python提供了for循环和while循环，下面是在大多数编程语言中的循环语句的一般形式：

![](https://upload-images.jianshu.io/upload_images/7600498-387855c36b440d57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```
i = 1
while i < 10:   
    i += 1
    if i%2 > 0:     # 非双数时跳过输出
        continue
    print i         # 输出双数2、4、6、8、10
 
i = 1
while 1:            # 循环条件为1必定成立
    print i         # 输出1~10
    i += 1
    if i > 10:     # 当i大于10时跳出循环
        break
```

```
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
fruits = ['banana', 'apple',  'mango']
for index in range(len(fruits)):
   print '当前水果 :', fruits[index]
 
print "Good bye!"


当前水果 : banana
当前水果 : apple
当前水果 : mango
Good bye!
```
python提供了两个非常重要的功能来处理python程序在运行中出现的异常和错误。你可以使用该功能来调试python程序。

什么是异常？
异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。一般情况下，在Python无法正常处理程序时就会发生一个异常.。异常是Python对象，表示一个错误。当Python脚本发生异常时我们需要捕获处理它，否则程序会终止执行。

异常处理
捕捉异常可以使用try/except语句。try/except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。如果你不想在异常发生时结束你的程序，只需在try里捕获它。

以下为简单的try....except...else的语法：

```
try:
<语句>        #运行别的代码
except <名字>：
<语句>        #如果在try部份引发了'name'异常
except <名字>，<数据>:
<语句>        #如果引发了'name'异常，获得附加的数据
else:
<语句>        #如果没有异常发生
```

```
#!/usr/bin/python
# -*- coding: UTF-8 -*-

try:
    fh = open("testfile", "w")
    fh.write("这是一个测试文件，用于测试异常!!")
except IOError:
    print "Error: 没有找到文件或读取文件失败"
else:
    print "内容写入文件成功"
    fh.close()

$ python test.py 
Error: 没有找到文件或读取文件失败
```

> Python代码书写建议
    4个空格缩进
    单行长度79内
    注释独占1行
    函数文档字符串
    操作符两侧空格
    类，函数，变量命名规范
 


######   参数、解包、变量
在运行程序时，可能需要根据不同的条件，输入不同的命令行选项来实现不同的功能。就需要给程序传递不同的输入，参数是外部的变量。<笨办法学Python>中给出了很好的解释：

```
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
from sys import argv

script, first, second, third = argv

print "The script is called:", script
print "Your first variable is:", first
print "Your second variable is:", second
print "Your third variable is:", third
```
 第一行代码中，我们用到一个import语句，这是将Python的功能模块加入你自己脚本的方法。Python 不会一下子将它所有的功能提供给你，而是让你需要什么就调用什么。这样可以让你的程序更加精简，而后面的程序员看到你的代码的时候，这些“import”语句可以作为提示，让他们明白你的代码用到了哪些功能。

argv就是所谓的“参数变量(argument variable)”，它是一个非常标准的编程术语。在其他的编程语言里你也可以看到它。这个变量包含了你传递给 Python 的参数。通过后面的练习你将对它有更多的了解。

代码的第3行将 argv进行“解包(unpack)”，与其将所有参数放到同一个变量下面，我们将每个参数赋予一个变量名： script, first, second, 以及 third。这也许看上去有些奇怪,不过”解包”可能是最好的描述方式了。它的含义很简单：“把 argv 中的东西解包，将所有的参数依次赋予左边的变量名”。

```
$ python ex13.py stuff things that
The script is called: ex13.py
Your first variable is: stuff
Your second variable is: things
Your third variable is: that
```

对一段程序（函数也好）参数可以理解为Windows软件的一个个按钮，通过运行前的指定来控制程序内部的运行，已达到我们需要的输出要求。

###### 函数

说到函数，不一样的人会对它有不一样的理解和使用方法，不过我只会教你现在能用到的最简单的使用方式。

函数可以做三样事情：

>它们给代码片段命名，就跟“变量”给字符串和数字命名一样。
它们可以接受参数，就跟你的脚本接受argv一样。
通过使用 #1 和 #2，它们可以让你创建“微型脚本”或者“小命令”。

python中你可以使用def新建函数。

```
# -*- coding: UTF-8 -*-

mydna= "ACTGCTCTAGCTAAGCA"
def DNA_complement(sequence):
    sequence = sequence.upper()
    sequence = sequence.replace('A', 't')
    sequence = sequence.replace('T', 'a')
    sequence = sequence.replace('C', 'g')
    sequence = sequence.replace('G', 'c')
    return sequence.upper()
 
def DNA_reverse(sequence):
    sequence = sequence.upper()
    return sequence[::-1]

print DNA_complement(mydna)
print DNA_reverse(DNA_complement(mydna)) #反向互补序列

TGACGAGATCGATTCGT
TGCTTAGCTAGAGCAGT
```

###### 文件读写

读写文件就是请求操作系统打开一个文件对象（文件描述符），然后通过操作系统提供的接口从这个文件对象中读写文件。Python 提供了必要的函数和方法进行默认情况下的文件基本操作。你可以用 file 对象做大部分的文件操作。

```
file object = open(file_name [, access_mode][, buffering])
```
+ file_name：file_name变量是一个包含了你要访问的文件名称的字符串值。
+ access_mode：access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。
+ buffering:如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。

![](https://upload-images.jianshu.io/upload_images/7600498-90f1c73d742fa622.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
# 打开一个文件
fo = open("foo.txt", "w")
fo.write( "www.runoob.com!\nVery good site!\n")
 
# 关闭打开的文件
fo.close()
```

```
try:
    with open("1.log", "r") as f:
        print(f.read())
except:
    print("打开文件异常")
```
当我们写文件时，系统往往不会立即写入，而是先放到内存里缓存起来，空闲时慢慢写入。只有调用close()方法时，操作系统才能立即写入。为了防止忘记调用close()，所以用with语句比较保险


###### os文件管理 

在 Linux 中，操作系统提供了很多的命令（例如：ls、cd），用于文件和目录管理。在 Python 中，有一个 os 模块，也提供了许多便利的方法来管理文件和目录。
os：语义为操作系统。所以，os 模块提供的肯定是操作系统相关的功能了（与具体的平台无关）。

如果用 dir() 查看 os，会发现内容相当多。下面，只列出文件和目录的相关方法：

|目的|方法|
|:-:|:-:|
|得到当前工作目录，即当前Python脚本工作的目录路径:|os.getcwd()|
|返回指定目录下的所有文件和目录名:|os.listdir()|
|删除一个文件:|os.remove()|
|删除多个目录：|os.removedirs()|
|检验给出的路径是否是一个文件：|os.path.isfile()|
|检验给出的路径是否是一个目录：|os.path.isdir()|
|判断是否是绝对路径：|os.path.isabs()|
|检验给出的路径是否真的存在:|os.path.exists()|
|返回一个路径的目录名和文件名：|os.path.split()|
|分离扩展名：|os.path.splitext()|
|获取路径名：|os.path.dirname()|
|获取文件名：|os.path.basename()|
|运行shell命令:|os.system()|
|读取和设置环境变量:|os.getenv()|
|给出当前平台使用的行终止符:|os.linesep(Windows使用'\r\n'，Linux使用'\n'而Mac使用'\r')|
|指示你正在使用的平台：|os.name|
|重命名：|os.rename(old,|
|创建多级目录：|os.makedirs()|
|创建单个目录：|os.mkdir()|
|获取文件属性：|os.stat(file)|
|修改文件权限与时间戳：|os.chmod(file)|
|终止当前进程：|os.exit()|
|获取文件大小：|os.path.getsize()|
|转换path的大小写和斜杠：|os.path.normcase(path)|
|规范path字符串形式：|os.path.normpath(path)|
|返回path的真实路径：|os.path.realpath(path)|
|从start开始计算相对路径：|os.path.relpath(path[,start])|
|切换目录：|os.chdir("path")|


#####  如何用Python解决我们的问题

知道基本的数据类型以及语法结构，遇到问题就可以考虑用Python来解决了。那么如何用程序来解决问题呢？



![](https://upload-images.jianshu.io/upload_images/7600498-d4c927249cf9571e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



我想给你介绍一个使用python创建某类东西的过程，也就是“面向对象编程”（OOP）。我把它叫做一个过程，是因为我将给出一系列按顺序进行的步骤，但是你也不应该死板的遵循这个步骤，企图用它解决所有难题。它们对于许多编程问题只是一个良好的开头，而不应该被认为是解决这些问题的唯一方法。这个过程只是一个你可以遵循的方法：

>写出或画出你的问题
从1中提炼关键问题并搜索相关资料
为2中的问题创建一个有层次结构的类和对象映射
编写类和测试代码，并保证他们运行
重复并精炼

按照这个顺序执行流程，叫做“**自顶向下**”的方式，意思是说，它从非常抽象宽松的想法开始，然后慢慢提炼，直到想法是坚实的东西，然后你再开始编码。

首先我只是写出这个问题，并试图想出任何我想要的东西就可以了。也许我会画一两个图表，或者某种可能的地图，甚至给自己写了一系列的电子邮件描述这个问题。这给了我表达了问题的关键概念的方法，并探测出我对于这个游戏有什么具体的想法和了解。

接下来，我浏览这些笔记，图表以及描述，通过这些记录我找到我需要的关键问题点。有一个简单的技巧：

> 简单地列出你的笔记和图表中所有的名词和动词,然后写出他们是如何相关的。

这一步其实也我为我下一步要写的类、对象、以及函数等提供了命名列表。我利用这个概念列表，研究任何我不明白的地方，如果我需要，我还可以进一步完善它们。

一旦我完成这个列表，我可以创建的一个简单的轮廓/树用来说明这些概念之间的关系。你还可以对着你的名词列表并询问“这个名词和其他的是一个概念吗？或者它们有一个通用的父类吗，那它们的父类是什么？”持续检查，直到你得到一个有层次结构的类，它应该像一棵简单的树或者图表。然后检查你的动词列表，看它们是否可以作为函数的名字添加到你的类树种。

随着这棵类树的生成，我坐下来写一些基本的框架代码，代码中只包括刚才提到的类，类中包含的函数。然后我再写一个测试用例，用来检验我刚才写的类是正确的。有时候我可能只需要在开始写一段测试代码，但是更多的时候，我需要写一段测试，再写一段代码，再写一段测试...直到整个项目完成。

>  代码是测试出来的。

Python库：电池
python内置了众多预编译并可移植的功能模块，涵盖了从字符模式到网络编程等一系列应用级编程任务；此外，python可通过自行开发的库和众多的第三方库简化编程，第三方库包括网站开发、数值计算、串口编写、游戏开发等各个应用场景。

往往一个库是针对某一个问题的一套解决方案，如office办公自动化，web开发等。沿着一个库来系统学习某一领域，也是一个不错的选择。


![](https://upload-images.jianshu.io/upload_images/7600498-997cc1bae80429c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


学习 python 文档的原则就是：熟悉常用库的大部分常用API。

+ string：包含各种简单的字符串处理方法，对于简单的字符串处理操作使用这里面的方法即可，不要动不动就写个正则表达式。

+ re：字符处理终极模块。好好掌握正则表达式语法，掌握里面的几个匹配方法，掌握 Match Object 的用法，捕获组的用法等。需要指出的是如果能用 string 模块处理的就尽量不用正则表达式，杀鸡不用牛刀。

+ datetime，calender：我对于涉及时间处理的情况倒不多，一般就是获取一下当前时间，根据时间的字符串构造 datetime 对象，格式化时间输出等，因此掌握其常用的几个对象和方法即可。

+ math，random，statistics：非专门的数学程序偶尔也会涉及一点数学运算，这几个模块提供了最基本的数学运算方法。当然专门的数学计算我会使用 numpy，pandas 等。然而掌握标准库的基本模块同样很重要，你不会想为了一个简单的需求而不得不去安装一个 numpy。



###### 怎样学习任何一种编程语言 

1. 找到关于这种语言的书或介绍性读物
2. 通读这份资料，把里边的代码写下来并运行起来。
3. 一边读书一边写代码，同时做好笔记 
4. 使用这种语言实现一些你用另一种熟悉的语言做过的程序组件。
5. 阅读别人使用这种语言写的代码，试着仿照他们的方式写代码。

 







---

参考

[https://www.python.org/](https://www.python.org/)
 [Python简史](https://www.cnblogs.com/vamei/archive/2013/02/06/2892628.html)
[《Python之禅》的翻译和解释](https://blog.csdn.net/gzlaiyonghao/article/details/2151918)
[你为什么用 Python？](https://www.zhihu.com/question/23593350)
[为什么要学习Python？这10个理由足够了！](https://segmentfault.com/a/1190000017319797)
[学习Python的4个原因](https://cloud.tencent.com/developer/article/1340173)
[https://www.oschina.net/news/106438/tiobe-index-201905](https://www.oschina.net/news/106438/tiobe-index-201905)
[理解Python中列表，元组，字典，集合的区别](https://blog.csdn.net/Yeoman92/article/details/56289287)
[练习13.参数, 解包, 变量](https://www.kancloud.cn/kancloud/learn-python-hard-way/49888)
[Python实现DNA序列互补、反向、反向互补](http://blog.biochen.com/archives/651)
[https://realpython.com/what-can-i-do-with-python/](https://realpython.com/what-can-i-do-with-python/)
[https://plot.ly/](https://plot.ly/)
[怎么成为python的调包侠？](https://www.zhihu.com/question/54343794)
[43：基本的面向对象的分析和设计](https://www.w3cschool.cn/tzwdhj/8zms1ozt.html)
[https://www.zhihu.com/question/22100190](https://www.zhihu.com/question/22100190)







